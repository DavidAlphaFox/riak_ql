%% -------------------------------------------------------------------
%%
%% riak_ql_ddl_util: utility functions for use in the riak ddl helper
%%                   modules generated by the riak_ql_ddl_compiler
%%
%% Copyright (c) 2016 Basho Technologies, Inc.  All Rights Reserved.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------
-module(riak_ql_ddl_util).

-export([
         is_valid_delete_where_clause/1,
         make_delete_key/2
        ]).

-include("riak_ql_ddl.hrl").

-define(EMPTY_ERRORS, []).
-define(EMPTY_KVs,    []).

make_delete_key(#key_v1{ast = AST}, Where) ->
    KVs = make_KV(Where, ?EMPTY_KVs),
    Key = [proplists:get_value(K, KVs) || ?SQL_PARAM{name = [K]} <- AST],
    {ok, Key}.

is_valid_delete_where_clause(Where) ->
    case is_valid2(Where, ?EMPTY_ERRORS) of
        ?EMPTY_ERRORS -> true;
        Errors        -> {error, Errors}
    end.

is_valid2([], Errors) ->
    %% we don't care about normalising the errors, but we do about
    %% the results
    lists:flatten(Errors);
is_valid2([{and_, LHS, RHS} | T], Errors) ->
    E1 = is_valid2([LHS], ?EMPTY_ERRORS),
    E2 = is_valid2([RHS], ?EMPTY_ERRORS),
    is_valid2(T, E1 ++ E2 ++ Errors);
is_valid2([{'=', _Field, _Val} | T],  Errors) ->
    is_valid2(T, Errors);
is_valid2([Other | T], Errors) ->
    Msg = io_lib:format("Invalid clause ~p~n", [Other]),
    is_valid2(T, [Msg | Errors]).

make_KV([], KVs) ->
    lists:flatten(KVs);
make_KV([{and_, LHS, RHS} | T], KVs) ->
    KV1 = make_KV([LHS], ?EMPTY_KVs),
    KV2 = make_KV([RHS], ?EMPTY_KVs),
    make_KV(T, KV1 ++ KV2 ++ KVs);
make_KV([{'=', Field, {_Type, Val}} | T], KVs) ->
    make_KV(T, [{Field, Val} | KVs]).

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").

is_valid_where_clause_test() ->
    W = [{and_,
          {'=',<<"time">>,{integer,11}},
          {and_,
           {'=',<<"region">>,{binary,<<"aaa">>}},
           {'=',<<"state">>,{binary,<<"bbb">>}}}}
        ],
    Expected = true,
    ?assertEqual(Expected, is_valid_delete_where_clause(W)).

is_valid_where_clause_failing_1_test() ->
    W = [{and_,
          {'=',<<"time">>,{integer,11}},
          {or_,
           {'=',<<"region">>,{binary,<<"aaa">>}},
           {'=',<<"state">>,{binary,<<"bbb">>}}}}
        ],
    Expected = "Invalid clause ",
    {error, Errors} = is_valid_delete_where_clause(W),
    {Got, _} = lists:split(15, Errors),
    ?assertEqual(Expected, Got).

is_valid_where_clause_failing_2_test() ->
    W = [{and_,
          {'=',<<"time">>,{integer,11}},
          {and_,
           {'>',<<"region">>,{binary,<<"aaa">>}},
           {flobber,<<"state">>,{binary,<<"bbb">>}}}}
        ],
    Expected = "Invalid clause ",
    {error, Errors} = is_valid_delete_where_clause(W),
    {Got, _} = lists:split(15, Errors),
    ?assertEqual(Expected, Got).

make_key_test() ->
    W = [{and_,
          {'=',<<"time">>,{integer,11}},
          {and_,
           {'=',<<"region">>,{binary,<<"aaa">>}},
           {'=',<<"state">>,{binary,<<"bbb">>}}}}
        ],
    Key = #key_v1{ast = [
                         ?SQL_PARAM{name = [<<"region">>]},
                         ?SQL_PARAM{name = [<<"state">>]},
                         ?SQL_PARAM{name = [<<"time">>]}
                        ]},
    {ok, Got} = make_delete_key(Key, W),
    Expected = [<<"aaa">>, <<"bbb">>, 11],
    ?assertEqual( Expected, Got).                        

-endif.
